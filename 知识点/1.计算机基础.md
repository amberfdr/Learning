##  1.计算机基础

### 硬件

### 软件

#### --系统软件

#### --应用软件

#### 1.1常见DOS命令讲解

- 切换盘符：d:+enter

- 列出该盘符所有目录：dir

- 创建目录：md anccc(make directory)

- 删除目录：rd ccc(remove directory)

- 单级进入目录：cd day01(change directory)

- 单级进入目录：cd  /javase/day01(change directory)

- 回退到根目录：cd/

- 删除文件：del c.mp3

  - 批量删除后缀相同的文件：del   *.text

- 清除屏幕：cls

- 退出控制台：exit

- 删除带内容的文件夹（会提示是否确定要删除）：rd /s dddd

- 删除带内容的文件夹（不会提示是否确定要删除）：rd /s /q dddd
####1.2 java语言

- 版本

  JavaSE是JavaME（安卓，通过机器访问的）和JavaEE（通过浏览器访问的）的基础

- 语言特点

  `开源`、面向对象、分布式处理、`跨平台`、健壮性、结构中立、多线程、高性能、动态、安全

- java语言跨平台原理：jvm充当翻译机，由jvm保证跨平台



- JRE(java runtime enviroment运行环境) 和 JDK(java development kit)
  - jre包含java虚拟机和java程序所需的核心类库等，如果只是想运行一个已经开发好的java程序，只需要jre
  - jdk包含了开发工具和jre，就不用单独安装jre了，其中开发工具：编译工具javac.exe，打包工具jre.exe
####1.3 安装

##### 1.3.1 下载jdk，安装最好不要有中文和特殊符号

- javac编译java文件，生成字节码文件，java运行字节码文件
##### 1.3.2 配置path环境变量
- 作用：让所有exe结尾的文件能在任何目录下使用
- 实现：方式2最优，当jdk 有多个的时候，容易误删path导致其它的软件不能使用。
  -  方式1：在系统变量的path中将jdk的bin目录的路径配置在最左边（按HOME键，ctrl+v）
  - 方式2：创建一个新的系统变量（JAVA_HOME）jdk的目录，在path的最左边添加`%JAVA_HOME%;`
##### 1.3.3 配置classpath环境变量
- 作用：让我们在任意目录下运行`.class`文件
- 实现：新建classpath系统变量，将class文件的目录配置在value里面。
### 2.Java语言基础
#### 2.1语法
##### 2.1.1 关键字
- 概述：被java语言赋予特定含义的单词
- 特点：全部是小写
- goto和const作为保留字（未来可能会作为关键字），目前不使用
##### 2.1.2 标识符
- 概述：类名、接口名、变量名等
- 规则：
	- 英文大小写字母
	- 数字字符
	- $ 和 _
- 注意事项
	- 不能以数字开头
	- 不能是java中的关键字
	- 区分大小写 
- 标识符中常见的命名规则：见名知义
	-  包：全部小写
		- 单级 fdr
		- 多级 cn.itcast
	-  类或者接口：
		- 单词首字母必须大写，驼峰命名`StringUtils` 
	-  方法或者变量：
		-  单词首字母必须小写，驼峰命名`addFruits`
	-  常量：
		- 每个单词必须大写，每个单词用下划线连接 `FRUITS_APPLE`
#####2.1.3 注释
- 单行注释
- 多行注释
- 文档注释：被javadoc工具解析生成一个说明书
#####2.1.4 常量
- 分类
	- 字面值常量
		 自定义常量	 
- 字面值常量
	- 字符串常量：“123”
	- 整数常量：100
	- 小数常量：1.2
	- 字符常量 ：'a'
	- 布尔常量：true false
	- 空常量：null
####2.2 进制

- 是一种进位方式。x进制，表示逢x进1。

- 计算机的电子原件的状：开，关，后来我们用1，0来代表开和关，由1，0组成的数据就是二进制数据。

- 换算

  | 1byte = 8bit  |
  | ------------- |
  | 1k = 1024byte |
  | 1m = 1024k    |
  | 1g = 1024m    |
  | 1t = 1024g    |

- 简化：
  - 二进制表达数据的表现形式太长
  - 把二进制的数据，从右开始，每n位一组合，最左边不够的时候，补0。分别计算出对应的十进制数值，最后把每个十进制的数据组合起来，就是一个x进制数据。
    - 八进制，每三位一组合
    - 十六进制，每四位一组合

  ![1562851160007](C:\Users\24025\AppData\Local\Temp\1562851160007.png)

  ![1562851212594](C:\Users\24025\AppData\Local\Temp\1562851212594.png)

- 规则：进制越大，表现形式越短。
#####2.2.1 不同进制
- 二进制：以0b开头，由0,1组成
- 八进制：以0x开头
- 十进制：默认整数是十进制
- 十六进制：以0x开头，由0,1,....9,a,b,c,d,e,f(大小写均可)组成
#####2.2.2进制的转换
- 八进制转换成十六进制，十进制作为中间桥梁，先将八进制转换成十进制，再将十进制转换成十六进制。
- 十六进制转十进制，除以十，倒着取余数。
####3.1原码，反码和补码
- 计算机在操作的时候，都是采用数据对应的二进制的补码来计算的。
#####3.1.1原码
- 正数的原码最高位是0
- 负数的原码最高位是1
- 其他的是数值位
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| +7   | 0      | 0000111 |
| -7   | 1      | 0000111 |
#####3.1.2反码
- 正数的反码与原码相同
- 负数的反码与原码是符号位相同，数值位取反，就是1变0，0变1。
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| +7   | 0      | 0000111 |
| -7   | 1      | 1111000 |
#####3.1.3补码
- 正数的补码与原码相同
- 负数的补码是在反码的基础上加1.
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| +7   | 0      | 0000111 |
| -7   | 1      | 1111001 |
#####3.1.4练习
- 已知某数x的原码为10110100B，试求x的补码和反码。
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| 原码   | 1      | 0110100 |
| 反码   | 1      | 1001011 |
| 补码   | 1      | 1001100 |
-  已知某数x的补码11101110B，试求其原码。
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| 补码   | 1      | 1101110 |
| 反码   | 1      | 1101101 |
| 原码   | 1      | 0010010 |

#### 3.2数据类型

- 基本数据类型
	- 整数默认的是int类型
	- 浮点数默认的是double类型 
	- 长整型后缀用L或者l标记。建议使用L。
	- 单精度浮点数用F或者f标记。建议使用F。
| 4类8种 | 类型    | 占用字节数 | 表述范围           |
| ------ | ------- | ---------- | ------------------ |
| 整数   | byte    | 1          | -128 ~ 127（-2^7） |
|        | short   | 2          | -2^15 ~ 2^15 - 1   |
|        | int     | 4          | -2^31 ~ 2^31 - 1   |
|        | long    | 8          | ..........         |
| 浮点数 | float   | 4          | ..........         |
|        | double  | 8          | ..........         |
| 字符   | char    | 2          | ..........         |
| 布尔   | boolean | 1          | ..........         |
- 引用数据类型（类，接口，数值）
#####3.2.1使用变量的注意事项
- 作用域
	- 在同一个作用域中不能定义同名的变量。
- 初始化值
	- 没有初始化的变量不能直接使用。
	- 不一定在定义的时候初始化，只要在使用前给值就行。  
#####3.2.2数据类型转换
######3.2.2.1默认转化（从小到大的计算）
| byte | short | char-int-long-float-double|
| ---- | ----- | ------------------------------------------------- |
| byte | short | char相互之间不转换，他们参与运算首先转换为int类型 |
- long:8个字节，float:4个字节为什么转换顺序是从long---> float
  - 它们底层的存储结构不同（可以作了解）
  - float的数据范围比long的数据范围大

![562944886149](C:\Users\24025\AppData\Local\Temp\1562944886149.png)

######3.2.2.2强制转化(从大的数据类型转换到小的数据类型)

- 缺点：可能会缺失精度

- 思考题：

  ```java
  class DataTypeDemo{
      public static main(String[] args){
          //1.请问下面有没有问题？
          double d = 12.345;
          float f = d;// float f = (float) d;
          //有问题，从大的数据类型转换成小的，要强制转换 
          //2.看看下面这两个定义有没有区别？
          float f1 = (float)12.345;
          float f2 = 12.345F;
          //有区别，前者：double型的12.345被强制转换成float型，精度会丢失，后者，12.345F就代表是float类型，没有精度丢失
      }
  }
  ```

- 面试题（强制转换后数据溢出后的结果怎么算----->问题1）

  ```java
  class DataTypeDemo{
      public static main(String[] args){
          //问题1：哪句会编译失败呢？为什么呢？
          byte b1 = 3,b2 = 4,b;
          b = b1 + b2;//类型提升，所以有问题
          b = 3 + 4;
          //解：b = b1 + b2;b1和b2都是byte类型，byte类型作加法，首先转换成int类型，int类型再转换成byte类型，就是大转小了，要求强制转换才行。b = 3 + 4;常量，先把结果计算出来，然后看是否在byte范围内，如果在就不报错。在编译阶段，常量就会计算了。
          
          byte c = (byte) 130;
          /**
          问题2：怎样赋值才正确呢？结果是多少呢？
          byte c = (byte)130;
          计算机中数据的运算都是补码进行的，而要得到补码，首先要计算出数据的二进制。
          A.获取130这个数的二进制（即原码）
          130整数类型，128+2
          00000000 00000000 00000000 10000010
          这是130的原码，也是反码，还是补码
          B.做截取操作，截成byte类型的了(操作的过程是补码，因为计算机中数据的运算都是补码进行的)
          10000010
          这个结果是补码
          C.已知补码求原码
               符号位  数值位
          补码： 1     0000010
          反码： 1     0000001
          原码： 1     1111110
          结果为：-126
        */
          
      }
  }
  ```

- 字符串参与运算

  ```java
  /*字符串数据和其他数据做+,结果是字符串类型，
  这里的+不是加法运算，而是字符串连接符。
  System.out.println("hello"+'a'+1);//helloa1
  System.out.println('a'+1+"hello");//98hello
  System.out.println("5+5"+5+5);//5+5=55
  System.out.println(5+5"=5+5");//10=5+5
  ```
#####3.2.3运算符
######3.2.3.1分类

#######1.算术运算符

- 整数相除得到的只能是整数，如果想得到小数，可以把其中的整数变成浮点数
- %取余 /整除
- ++ -- 是针对变量的，常量经过初始化后是不可变的。

#######2.赋值运算符

- 面试题

  ```java
  short s = 1；
  s = s+1;//错，short要转换成int作运算，小转大，要强制转换
  short s = 1;s+=1;
  //正确，扩展的赋值运算符其实隐含了一个强制类型转换，s+=1  等价于   s=(s的数据类型)（s+1）
  ```

  ​

#######3.比较运算符

#######4.逻辑运算符

- &&和&的区别？
  - &&：短路与，只要前面的是false，后面就不执行了
  - 开发中常用 &&  ||  ！

#######5.位运算符

- 注意：要做位运算，首先要把数据转换为二进制
- 分类： & | ^ ~
- 位异或^：一个数据对另一个数据异或两次，自身不变
  - 应用：数据加密，但是容易被破解，所以开发中不常用。
- int a = 3,b = 4;


- 规则1

| 分类            | 规则                                       |
| --------------- | ------------------------------------------ |
| &位与运算       | 有0则0                                     |
| \|位或运算 |位或运算      |
| ^位异或运算     | 相同则0，不同则1                           |
| ~按位取反运算符 | 0变1，1变0                                 |

- 例子（按位取反）

| 整数3                           | 00000000  | 00000000 | 00000000 | 00000011 |
| ------------------------------- | --------- | -------- | -------- | -------- |
| 对整数3按位取反（得到的是补码） | ~11111111 | 11111111 | 11111111 | 11111100 |
| 补码                            | 11111111  | 11111111 | 11111111 | 11111100 |
| 反码                            | 11111111  | 11111111 | 11111111 | 11111011 |
| 原码                            | 10000000  | 00000000 | 00000000 | 00000100 |
| 结果是 -4                       |           |          |          |          |

  - 规则2

| 分类            | 规则                                       |
| --------------- | ------------------------------------------ |
| <<左移          | 左边最高位丢弃，右边补齐0                  |
| >>右移          | 最高位是0，左边补齐0，最高位是1，左边补齐1 |
| >>>无符号右移   | 无论最高位是0还是1，左边补齐0              |
  - 例子（规则2）

  ```java
class DataTypeDemo{
    public static main(String[] args){
        //<< 把<<左边的数据乘以2的移动次幂
        System.out.println(3 << 2);//3*2^2=12
        //>> 把>>左边的数据除以2的移动次幂
        System.out.println(24 >> 2);//24 / 2^2 = 24/4 = 6
        System.out.println(3 >>> 2);
        System.out.println(-24 >> 2); 
	   System.out.println(-24 >>> 2);
        /*
	计算出3的二进制：11
		00000000 00000000 00000000 00000011
	(00)000000 00000000 00000000 0000001100
		
	>>的移动：	
	计算出24的二进制：11000
		原码：10000000 00000000 00000000 00011000
		反码：11111111 11111111 11111111 11100111
		补码：11111111 11111111 11111111 11101000
		
		11111111 11111111 11111111 11101000
		1111111111 11111111 11111111 111010(00) 补码
		
		补码：1111111111 11111111 11111111 111010
		反码：1111111111 11111111 11111111 111001
		原码：1000000000 00000000 00000000 000110
		
		结果：-6
		
	>>>的移动：
		计算出24的二进制：11000
		原码：10000000 00000000 00000000 00011000
		反码：11111111 11111111 11111111 11100111
		补码：11111111 11111111 11111111 11101000
		
		11111111 11111111 11111111 11101000
		0011111111 11111111 11111111 111010(00)
		
		结果：
*/
    }
}
  ```

- 面试题：
  - 1.请用最有率的方式写出计算2乘以8的结果？ 2 << 3
  - 2.请自己实现两个整数变量的交换
    ```java
        class OperatorTest{
            int a = 10;
            int b = 20;
            //方式1：tmp(开发用)
            /*
            int c = a;
            a = b;
            b = c;
            */
            //方式2：用位异或实现（面使用）
            /*
            a = a ^ b；
            b = a ^ b;//(a ^ b) ^ b = a
            a = a ^ b;//(a ^ b) ^ a = b
            */
            //方式3：用变量相加的做法
            /*
            a = a + b;
            b = a - b;
            a = a - b;
            */
        }
    ```






#######6.三目运算符


