## 1.计算机基础

### 硬件

### 软件

#### --系统软件

#### --应用软件

#### 1.1常见DOS命令讲解

- 切换盘符：d:+enter

- 列出该盘符所有目录：dir

- 创建目录：md anccc(make directory)

- 删除目录：rd ccc(remove directory)

- 单级进入目录：cd day01(change directory)

- 单级进入目录：cd  /javase/day01(change directory)

- 回退到根目录：cd/

- 删除文件：del c.mp3

  - 批量删除后缀相同的文件：del   *.text

- 清除屏幕：cls

- 退出控制台：exit

- 删除带内容的文件夹（会提示是否确定要删除）：rd /s dddd

- 删除带内容的文件夹（不会提示是否确定要删除）：rd /s /q dddd
####1.2 java语言

- 版本

  JavaSE是JavaME（安卓，通过机器访问的）和JavaEE（通过浏览器访问的）的基础

- 语言特点

  `开源`、面向对象、分布式处理、`跨平台`、健壮性、结构中立、多线程、高性能、动态、安全

- java语言跨平台原理：jvm充当翻译机，由jvm保证跨平台



- JRE(java runtime enviroment运行环境) 和 JDK(java development kit)
  - jre包含java虚拟机和java程序所需的核心类库等，如果只是想运行一个已经开发好的java程序，只需要jre
  - jdk包含了开发工具和jre，就不用单独安装jre了，其中开发工具：编译工具javac.exe，打包工具jre.exe
####1.3 安装

##### 1.3.1 下载jdk，安装最好不要有中文和特殊符号

- javac编译java文件，生成字节码文件，java运行字节码文件
##### 1.3.2 配置path环境变量
- 作用：让所有exe结尾的文件能在任何目录下使用
- 实现：方式2最优，当jdk 有多个的时候，容易误删path导致其它的软件不能使用。
  -  方式1：在系统变量的path中将jdk的bin目录的路径配置在最左边（按HOME键，ctrl+v）
  - 方式2：创建一个新的系统变量（JAVA_HOME）jdk的目录，在path的最左边添加`%JAVA_HOME%;`
##### 1.3.3 配置classpath环境变量
- 作用：让我们在任意目录下运行`.class`文件
- 实现：新建classpath系统变量，将class文件的目录配置在value里面。
### 2.Java语言基础
#### 2.1语法
##### 2.1.1 关键字
- 概述：被java语言赋予特定含义的单词
- 特点：全部是小写
- goto和const作为保留字（未来可能会作为关键字），目前不使用
##### 2.1.2 标识符
- 概述：类名、接口名、变量名等
- 规则：
	- 英文大小写字母
	- 数字字符
	- $ 和 _
- 注意事项
	- 不能以数字开头
	- 不能是java中的关键字
	- 区分大小写 
- 标识符中常见的命名规则：见名知义
	-  包：全部小写
		- 单级 fdr
		- 多级 cn.itcast
	-  类或者接口：
		- 单词首字母必须大写，驼峰命名`StringUtils` 
	-  方法或者变量：
		-  单词首字母必须小写，驼峰命名`addFruits`
	-  常量：
		- 每个单词必须大写，每个单词用下划线连接 `FRUITS_APPLE`
#####2.1.3 注释
- 单行注释
- 多行注释
- 文档注释：被javadoc工具解析生成一个说明书
#####2.1.4 常量
- 分类
	- 字面值常量
		 自定义常量	 
- 字面值常量
	- 字符串常量：“123”
	- 整数常量：100
	- 小数常量：1.2
	- 字符常量 ：'a'
	- 布尔常量：true false
	- 空常量：null
####2.2 进制

- 是一种进位方式。x进制，表示逢x进1。

- 计算机的电子原件的状：开，关，后来我们用1，0来代表开和关，由1，0组成的数据就是二进制数据。

- 换算

  | 1byte = 8bit  |
  | ------------- |
  | 1k = 1024byte |
  | 1m = 1024k    |
  | 1g = 1024m    |
  | 1t = 1024g    |

- 简化：
  - 二进制表达数据的表现形式太长
  - 把二进制的数据，从右开始，每n位一组合，最左边不够的时候，补0。分别计算出对应的十进制数值，最后把每个十进制的数据组合起来，就是一个x进制数据。
    - 八进制，每三位一组合
    - 十六进制，每四位一组合

  ![1562851160007](C:\Users\24025\AppData\Local\Temp\1562851160007.png)

  ![1562851212594](C:\Users\24025\AppData\Local\Temp\1562851212594.png)

- 规则：进制越大，表现形式越短。
#####2.2.1 不同进制
- 二进制：以0b开头，由0,1组成
- 八进制：以0x开头
- 十进制：默认整数是十进制
- 十六进制：以0x开头，由0,1,....9,a,b,c,d,e,f(大小写均可)组成
#####2.2.2进制的转换
- 八进制转换成十六进制，十进制作为中间桥梁，先将八进制转换成十进制，再将十进制转换成十六进制。
- 十六进制转十进制，除以十，倒着取余数。
####3.1原码，反码和补码
- 计算机在操作的时候，都是采用数据对应的二进制的补码来计算的。
#####3.1.1原码
- 正数的原码最高位是0
- 负数的原码最高位是1
- 其他的是数值位
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| +7   | 0      | 0000111 |
| -7   | 1      | 0000111 |
#####3.1.2反码
- 正数的反码与原码相同
- 负数的反码与原码是符号位相同，数值位取反，就是1变0，0变1。
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| +7   | 0      | 0000111 |
| -7   | 1      | 1111000 |
#####3.1.3补码
- 正数的补码与原码相同
- 负数的补码是在反码的基础上加1.
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| +7   | 0      | 0000111 |
| -7   | 1      | 1111001 |
#####3.1.4练习
- 已知某数x的原码为10110100B，试求x的补码和反码。
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| 原码   | 1      | 0110100 |
| 反码   | 1      | 1001011 |
| 补码   | 1      | 1001100 |
-  已知某数x的补码11101110B，试求其原码。
|      | 符号位 | 数值位  |
| ---- | ------ | ------- |
| 补码   | 1      | 1101110 |
| 反码   | 1      | 1101101 |
| 原码   | 1      | 0010010 |

#### 3.2数据类型

- 基本数据类型
	- 整数默认的是int类型
	- 浮点数默认的是double类型 
	- 长整型后缀用L或者l标记。建议使用L。
	- 单精度浮点数用F或者f标记。建议使用F。
| 4类8种 | 类型    | 占用字节数 | 表述范围           |
| ------ | ------- | ---------- | ------------------ |
| 整数   | byte    | 1          | -128 ~ 127（-2^7） |
|        | short   | 2          | -2^15 ~ 2^15 - 1   |
|        | int     | 4          | -2^31 ~ 2^31 - 1   |
|        | long    | 8          | ..........         |
| 浮点数 | float   | 4          | ..........         |
|        | double  | 8          | ..........         |
| 字符   | char    | 2          | ..........         |
| 布尔   | boolean | 1          | ..........         |
- 引用数据类型（类，接口，数值）
#####3.2.1使用变量的注意事项
- 作用域
	- 在同一个作用域中不能定义同名的变量。
- 初始化值
	- 没有初始化的变量不能直接使用。
	- 不一定在定义的时候初始化，只要在使用前给值就行。  
#####3.2.2数据类型转换
######3.2.2.1默认转化（从小到大的计算）
| byte | short | char-int-long-float-double                        |
| ---- | ----- | ------------------------------------------------- |
| byte | short | char相互之间不转换，他们参与运算首先转换为int类型 |

![562944886149](C:\Users\24025\AppData\Local\Temp\1562944886149.png)

######3.2.2.1强制转化(从大的数据类型转换到小的数据类型)

- 缺点：可能会缺失精度

- 思考题：

  ```java
  class DataTypeDemo{
      public static main(String[] args){
          //1.请问下面有没有问题？
          double d = 12.345;
          float f = d;// float f = (float) d;
          //有问题，从大的数据类型转换成小的，要强制转换 
          //2.看看下面这两个定义有没有区别？
          float f1 = (float)12.345;
          float f2 = 12.345F;
          //有区别，前者：double型的12.345被强制转换成float型，精度会丢失，后者，12.345F就代表是float类型，没有精度丢失
      }
  }
  ```

- 面试题（强制转换后数据溢出后的结果怎么算----->问题1）

  ```java
  class DataTypeDemo{
      public static main(String[] args){
          //问题1：哪句会编译失败呢？为什么呢？
          byte b1 = 3,b2 = 4,b;
          b = b1 + b2;//类型提升，所以有问题
          b = 3 + 4;
          //解：b = b1 + b2;b1和b2都是byte类型，byte类型作加法，首先转换成int类型，int类型再转换成byte类型，就是大转小了，要求强制转换才行。b = 3 + 4;常量，先把结果计算出来，然后看是否在byte范围内，如果在就不报错。在编译阶段，常量就会计算了。
          
          byte c = (byte) 130;
          /**
          问题2：怎样赋值才正确呢？结果是多少呢？
          byte c = (byte)130;
          计算机中数据的运算都是补码进行的，而要得到补码，首先要计算出数据的二进制。
          A.获取130这个数的二进制（即原码）
          130整数类型，128+2
          00000000 00000000 00000000 10000010
          这是130的原码，也是反码，还是补码
          B.做截取操作，截成byte类型的了(操作的过程是补码，因为计算机中数据的运算都是补码进行的)
          10000010
          这个结果是补码
          C.已知补码求原码
               符号位  数值位
          补码： 1     0000010
          反码： 1     0000001
          原码： 1     1111110
          结果为：-126
        */
          
      }
  }
  ```

  ​

- 字符串参与运算

  ```java
  /*字符串数据和其他数据做+,结果是字符串类型，
  这里的+不是加法运算，而是字符串连接符。
  System.out.println("hello"+'a'+1);//helloa1
  System.out.println('a'+1+"hello");//98hello
  System.out.println("5+5"+5+5);//5+5=55
  System.out.println(5+5"=5+5");//10=5+5
  ```

  ​